# Shell

`Shell`  是一个命令行解释器，它为用户提供了向 `Linux` 内核发送请求以便运行程序的界面系统级程序。

`Shell`  还是一种功能强大的编程语言，易编写、易调试且灵活性很强。`Shell`  是解释执行的脚本语言，在 `Shell` 中可以直接调用 `Linux` 系统命令。

<img :src="$withBase('/images/linux/LinuxShell.jpg')" alt="LinuxShell">

## Shell 等分类

首个重要的标准 `Unix Shell` 是 1979 年底在 V7 Unix(AT&T第7版）中引入的，也就是 `Bourne shell`。

`Bill Joy` 于 20 世纪 80 年代早期，在伯克利的加利福尼亚大学开发了 `C shell`。它主要是为了让用户更容易的使用交互式功能，并把 ALGOL 风格的语法结构变成了 C 语言风格。它新增了命令历史、别名、文件名替换、作业控制等功能。

Bourne Again Shell (bash)是 GNU 计划的一部分，用来替代 `Bourne shell`。它用于基于 GNU 的系统如 `Linux`.大多数的 Linux(Red Hat,Slackware,Caldera）都以 `bash` 作为缺省的 `shell`，并且运行 `sh` 时，其实调用的是 `bash`。

我们可以通过查看 `/etc/shells` 来查看系统支持的 `shell`。

## 创建执行第一个 shell 程序

```bash
$ cd ~ && vi first.sh
# 写入内容：
# #!/bin/bash
# echo -e "\e[1;34m Hello world! \e[0m"
$ chmod 777 first.sh # 给予执行权限，也可以使用 bash first.sh 直接执行
```

## Bash 的基本功能

`Bash`，也就是 `Bourne Again Shell`，由于易用和免费，`Bash` 在日常工作中被广泛使用。

### 命令别名

利用 `alias` 命令，可以自定指令的别名。若仅输入 `alias`，则可列出目前所有的别名设置。

`alias` 的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在 `.profile` 或 `.cshrc` 中设定指令的别名。

语法：

```bash
alias[别名]=[指令名称]
```

实例：

为 `mkdir` 设置别名为 `mk`。

```bash
alias mk=mkdir
```

对应的我们可以使用 `unalias` 加上别名来删除别名，当然它也是临时的，永久移除需要在上面的配置文件中移除。

### 常用快捷键

* ctrl + l : 清屏。
* ctrl + c : 强制终止当前命令。
* ctrl + a : 光标移动到命令行行首。
* ctrl + e : 光标移动到命令行行尾。
* ctrl + u : 从光标所在位置删除到行首。

### HISTORY

`history` 用于显示指定数目的指令命令，读取历史命令文件中的目录到历史命令缓冲区和将历史命令缓冲区中的目录写入命令文件。

该命令单独使用时，仅显示历史命令，在命令行中，可以使用符号 `!` 执行指定序号的历史命令。例如，要执行第 2 个历史命令，则输入 `!2`。

历史命令是被保存在内存中的，当退出或者登录 Shell 时，会自动保存或读取。在内存中，历史命令仅能够存储 1000 条历史命令，该数量是由环境变量 HISTSIZE 进行控制。

语法：

```bash
history [选项] [参数]
```

常用参数：

* -c：清空当前历史命令；
* -w：将当前历史命令缓冲区命令写入历史命令文件中。
* -a：将历史命令缓冲区中命令写入历史命令文件中；
* -r：将历史命令文件中的命令读入当前历史命令缓冲区；

参数为 `n`：指定打印最近的 `n` 条历史命令。

### 历史命令

* 使用上下箭头调用以前的历史命令。
* 使用 “!n“ 重复执行第 `n` 条历史命令。
* 使用 “!!” 或则按 `Ctrl+P` 重复执行上一条命令。
* 使用 “!stirng” 重复执行最后一条以 `stirng` 字符串开头的命令。

### 输出重定向

**标准输入输出**。

| 设备 | 设备文件名 | 文件描述符 | 类型 |
| :-- | :-- | :-- | :-- |
| 键盘 | /dev/sdtin | 0 | 标准输入 |
| 显示器 | /dev/sdtout | 1 | 标准输出 |
| 显示器 | /dev/sdterr | 2 | 标准错误输出 |

**输出重定向**。

| 格式 | 作用 |
| :-- | :-- |
| 命令 > 文件 | 以覆盖的方式，把命令的正确输出重定向到指定的文件 |
| 命令 >> 文件 | 以追加的方式，把命令的正确输出重定向到指定的文件 |
| 命令 2>文件 | 以覆盖的方式，把命令的错误输出重定向到指定的文件 |
| 命令 2>>文件 | 以追加的方式，把命令的错误输出重定向到指定的文件 |
| 命令 > 文件 2>&1 | 以覆盖的方式，把命令正确和错误的输出都重定向到指定的文件 |
| 命令 >> 文件 2>&1 | 以追加的方式，把命令正确和错误的输出都重定向到指定的文件 |
| 命令 &>文件 | 以覆盖的方式，把命令的正确和错误的输出都重定向到指定的文件 |
| 命令 &>>文件 | 以追加的方式，把命令的正确和错误的输出都重定向到指定的文件 |
| 命令 >> 文件M 2>>文件2 | 以正确的输出追加到文件 1 中，把错误的输出追加到文件 2 中 |

常见的使用，当我们执行一个命令时，不需要它的输出结果时（成功和失败的），就可以使用 `<command> &>/dev/null` 格式的命令，它会将输出丢入系统的黑洞中。

计算字数：

利用 `wc` 指令我们可以计算文件的 `Byte` 数、字数、或是列数，若不指定文件名称、或是所给予的文件名为"-"，则 `wc` 指令会从标准输入设备读取数据。

语法：

```bash
wc [-clw][--help][--version][文件...]
```

常用选项：

* -w 或 --words 只显示字数。
* -l 或 --lines 只显示行数。
* -c 或 --bytes 或 --chars 只显示 Bytes 数。

在默认的情况下，`wc` 将计算指定文件的行数、字数，以及字节数。

### 常用符号

| 符号 | 格式 | 作用 |
| :-- | :-- | :-- |
| ; | 命令1 ; 命令2 | 多个命令顺序执行 |
| && | 命令1 && 命令2 | 逻辑与，当命令 1 正确执行后才会执行命令 2 |
| &#124;&#124; | 命令1 &#124;&#124; 命令2 | 逻辑或，当命令 1 没有正确执行才会执行命令 2 |

**管道符**
使用格式为 `命令1 | 命令2`，这样命令 1 的正确输出将会作为命令 2 的操作对象。

### 常用通配符

| 通配符 | 作用 |
| :-- | :-- |
| ? | 匹配一个任意字符 |
| * | 匹配零个或多个任意字符 |
| [] | 匹配括号中的任意一个字符 |
| [^] | 匹配不在括号中的任意一个字符 |
| '' | 其中的所有特殊符号都没有特殊意义 |
| "" | 除了 "$"、“`”、“\” 分别拥有调用变量的值、引用命令、转义符的意义外，其他特殊符号都没有特殊意义 |
| `` | 反引号与 `$()` 一样，其中内容是系统命令，在 Bash 中会先执行它 |
| $() | 与反引号一样，用来引用系统命令 |
| # | 在 Shell 脚本中，以 `#` 开头的表示注释 |
| \ | 转义符，将特殊符号变为普通符号。比如 `\$` 将不会当作变量引用 |
