# 反转链表

解题思路 1：

将前面 1-3 个节点的转换过程按步骤逐步写下来，然后从其中找出后续节点替换的一个规律，然后优化代码。

```rust
impl Solution {
  pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
    let prev = None;
    let mut curr = head?;

    if curr.next.is_none() {
      return Some(curr);
    }

    let mut next = curr.next;
    let mut next_value = next.unwrap();

    curr.next = prev;

    if next_value.next.is_none() {
      next_value.next = Some(curr);
      return Some(next_value);
    }

    let mut temp = next_value.next;
    next_value.next = Some(curr);

    loop {
      curr = next_value;
      next = temp;

      if next.is_none() {
        return Some(curr);
      }

      next_value = next.unwrap();
      temp = next_value.next;
      next_value.next = Some(curr);
    }
  }
}
```

官方解题思路：

在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。

补充描述：

1. 添加 prev 变量用来指向上一个已处理的节点（最开始的节点应该为 None）
2. 添加 curr 变量指向当前正在处理的节点
3. 添加 next 变量（在当前节点不为空的情况下指向当前节点的下一个节点，也就是待处理的节点）
4. 如果当前节点如果不为空，则开始处理当前节点
   1. 首先更新待处理的节点为当前节点的下一个节点（必须先记录，否则修改当前节点后就获取不到了）
   2. 更新正在处理的节点的 next 字段指向上一个已处理的节点
   3. 当前节点已处理，所以更新上一个节点为当前节点
   4. 更新当前节点为下一个待处理的节点
5. 重复第 4 步，直到当前处理的节点为空而退出循环，并返回上一个已经处理好的节点

```rust
impl Solution {
  pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
    let mut prev = None;
    let mut curr = head;

    while !curr.is_none() {
      let mut curr_value = curr.unwrap();
      let next = curr_value.next;

      curr_value.next = prev;
      prev = Some(curr_value);
      curr = next;
    }

    prev
  }
}
```

## 参考

- [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)
